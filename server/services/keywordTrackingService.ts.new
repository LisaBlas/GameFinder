import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

interface Keyword {
  id: number;
  name: string;
  count?: number;
}

export class KeywordTrackingService {
  private srcKeywordsPath: string;
  private distKeywordsPath: string;
  private keywords: Keyword[] = [];
  private pendingUpdates: Set<number> = new Set();
  private saveTimeout: NodeJS.Timeout | null = null;
  private readonly SAVE_DELAY = 5000; // 5 seconds
  private isWriting = false;
  private writeQueue: (() => void)[] = [];
  
  constructor() {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    
    // Set paths for both source and dist versions of the file
    this.srcKeywordsPath = path.join(process.cwd(), 'client/src/assets/all_keywords.json');
    this.distKeywordsPath = path.join(process.cwd(), 'dist/assets/all_keywords.json');
    
    console.log(`[KeywordTrackingService] Source keywords file: ${this.srcKeywordsPath}`);
    console.log(`[KeywordTrackingService] Dist keywords file: ${this.distKeywordsPath}`);
    
    // Check if the files exist
    if (!fs.existsSync(this.srcKeywordsPath)) {
      console.error(`[KeywordTrackingService] ERROR: Source keywords file not found at ${this.srcKeywordsPath}`);
    } else {
      console.log(`[KeywordTrackingService] Source keywords file found at ${this.srcKeywordsPath}`);
    }
    
    if (!fs.existsSync(this.distKeywordsPath)) {
      console.error(`[KeywordTrackingService] ERROR: Dist keywords file not found at ${this.distKeywordsPath}`);
    } else {
      console.log(`[KeywordTrackingService] Dist keywords file found at ${this.distKeywordsPath}`);
    }
    
    // Delete backup files if they exist
    const srcBackupPath = `${this.srcKeywordsPath}.backup`;
    if (fs.existsSync(srcBackupPath)) {
      try {
        fs.unlinkSync(srcBackupPath);
        console.log(`[KeywordTrackingService] Deleted source backup file at ${srcBackupPath}`);
      } catch (error: any) {
        console.error(`[KeywordTrackingService] Error deleting source backup file:`, error);
      }
    }
    
    const distBackupPath = `${this.distKeywordsPath}.backup`;
    if (fs.existsSync(distBackupPath)) {
      try {
        fs.unlinkSync(distBackupPath);
        console.log(`[KeywordTrackingService] Deleted dist backup file at ${distBackupPath}`);
      } catch (error: any) {
        console.error(`[KeywordTrackingService] Error deleting dist backup file:`, error);
      }
    }
    
    this.loadKeywords();
  }
  
  private loadKeywords(): void {
    try {
      // Try to load from dist first, as that's the one being used by the application
      if (fs.existsSync(this.distKeywordsPath)) {
        const data = fs.readFileSync(this.distKeywordsPath, 'utf-8');
        this.keywords = JSON.parse(data);
        console.log(`[KeywordTrackingService] Loaded ${this.keywords.length} keywords from dist file`);
      } else if (fs.existsSync(this.srcKeywordsPath)) {
        // Fall back to src file if dist doesn't exist
        const data = fs.readFileSync(this.srcKeywordsPath, 'utf-8');
        this.keywords = JSON.parse(data);
        console.log(`[KeywordTrackingService] Loaded ${this.keywords.length} keywords from src file`);
      } else {
        console.error('[KeywordTrackingService] Neither dist nor src keywords file exists');
        this.keywords = [];
        return;
      }
      
      // Initialize count property if it doesn't exist
      this.keywords = this.keywords.map(keyword => ({
        ...keyword,
        count: keyword.count || 0
      }));
      
      console.log(`[KeywordTrackingService] Loaded ${this.keywords.length} keywords with counts initialized`);
    } catch (error: any) {
      console.error('[KeywordTrackingService] Error loading keywords:', error);
      this.keywords = [];
    }
  }
  
  public trackKeywordUsage(keywordId: number): boolean {
    const keywordIndex = this.keywords.findIndex(k => k.id === keywordId);
    
    if (keywordIndex !== -1) {
      // Increment the count
      this.keywords[keywordIndex].count = (this.keywords[keywordIndex].count || 0) + 1;
      
      // Schedule a save
      this.pendingUpdates.add(keywordId);
      this.scheduleSave();
      
      console.log(`[KeywordTrackingService] Tracked usage of keyword: ${this.keywords[keywordIndex].name} (ID: ${keywordId}), new count: ${this.keywords[keywordIndex].count}`);
      return true;
    }
    
    console.log(`[KeywordTrackingService] Keyword ID ${keywordId} not found`);
    return false;
  }
  
  public trackKeywordUsageByName(keywordName: string): boolean {
    const keywordIndex = this.keywords.findIndex(
      k => k.name.toLowerCase() === keywordName.toLowerCase()
    );
    
    if (keywordIndex !== -1) {
      // Increment the count
      this.keywords[keywordIndex].count = (this.keywords[keywordIndex].count || 0) + 1;
      
      // Schedule a save
      this.pendingUpdates.add(this.keywords[keywordIndex].id);
      this.scheduleSave();
      
      console.log(`[KeywordTrackingService] Tracked usage of keyword by name: ${keywordName}, new count: ${this.keywords[keywordIndex].count}`);
      return true;
    }
    
    console.log(`[KeywordTrackingService] Keyword name "${keywordName}" not found`);
    return false;
  }
  
  public getKeywordUsage(keywordId: number): number {
    const keyword = this.keywords.find(k => k.id === keywordId);
    return keyword ? keyword.count || 0 : 0;
  }
  
  public getMostUsedKeywords(limit = 10): Keyword[] {
    return [...this.keywords]
      .filter(k => (k.count || 0) > 0)
      .sort((a, b) => (b.count || 0) - (a.count || 0))
      .slice(0, limit);
  }
  
  private scheduleSave(): void {
    if (this.saveTimeout === null) {
      this.saveTimeout = setTimeout(() => {
        this.saveKeywords();
        this.pendingUpdates.clear();
        this.saveTimeout = null;
      }, this.SAVE_DELAY);
    }
  }
  
  private saveKeywords(): void {
    if (this.isWriting) {
      // Queue this write operation
      this.writeQueue.push(() => this.saveKeywords());
      console.log(`[KeywordTrackingService] Write operation queued (${this.writeQueue.length} in queue)`);
      return;
    }
    
    this.isWriting = true;
    
    try {
      console.log(`[KeywordTrackingService] Saving keywords with ${this.pendingUpdates.size} pending updates`);
      
      // Save to both src and dist files
      this.saveToFile(this.srcKeywordsPath);
      this.saveToFile(this.distKeywordsPath);
      
    } catch (error: any) {
      console.error('[KeywordTrackingService] Error in saveKeywords:', error);
    } finally {
      this.isWriting = false;
      
      // Process next write operation in queue if any
      if (this.writeQueue.length > 0) {
        console.log(`[KeywordTrackingService] Processing next write operation from queue (${this.writeQueue.length} remaining)`);
        const nextWrite = this.writeQueue.shift();
        if (nextWrite) nextWrite();
      }
    }
  }
  
  private saveToFile(filePath: string): void {
    // Get absolute path to ensure we're writing to the correct location
    const absolutePath = path.resolve(filePath);
    console.log(`[KeywordTrackingService] Saving to: ${absolutePath}`);
    
    // Check if the file exists and is writable
    try {
      fs.accessSync(absolutePath, fs.constants.W_OK);
      console.log(`[KeywordTrackingService] File is writable: ${absolutePath}`);
    } catch (accessError: any) {
      console.error(`[KeywordTrackingService] File is not writable: ${absolutePath}`, accessError);
      console.log('[KeywordTrackingService] Attempting to write anyway...');
    }
    
    // First read the current file to ensure we have the latest data
    try {
      const currentData = fs.readFileSync(absolutePath, 'utf-8');
      const currentKeywords = JSON.parse(currentData);
      console.log(`[KeywordTrackingService] Read current file with ${currentKeywords.length} keywords`);
      
      // Update only the keywords that have changed
      this.pendingUpdates.forEach(keywordId => {
        const updatedKeyword = this.keywords.find((k: Keyword) => k.id === keywordId);
        if (updatedKeyword) {
          const currentKeyword = currentKeywords.find((k: Keyword) => k.id === keywordId);
          if (currentKeyword) {
            currentKeyword.count = updatedKeyword.count;
            console.log(`[KeywordTrackingService] Updated keyword ${updatedKeyword.name} count to ${updatedKeyword.count}`);
          }
        }
      });
      
      // Write the updated keywords back to the file
      fs.writeFileSync(absolutePath, JSON.stringify(currentKeywords, null, 2));
      console.log(`[KeywordTrackingService] Write operation completed for ${absolutePath}`);
      
      // Verify the file was written correctly
      try {
        const writtenData = fs.readFileSync(absolutePath, 'utf-8');
        const parsedData = JSON.parse(writtenData);
        console.log(`[KeywordTrackingService] Keywords saved successfully to ${absolutePath} (${parsedData.length} keywords)`);
        
        // Double-check a few keywords to ensure they were updated
        this.pendingUpdates.forEach(keywordId => {
          const keyword = parsedData.find((k: Keyword) => k.id === keywordId);
          if (keyword) {
            console.log(`[KeywordTrackingService] Verified keyword ${keyword.name} has count ${keyword.count} in ${absolutePath}`);
          }
        });
      } catch (verifyError: any) {
        console.error(`[KeywordTrackingService] Failed to verify written data in ${absolutePath}:`, verifyError);
      }
    } catch (readError: any) {
      console.error(`[KeywordTrackingService] Error reading current file ${absolutePath}:`, readError);
      console.log(`[KeywordTrackingService] Falling back to writing entire keywords array to ${absolutePath}`);
      
      // Fall back to writing the entire keywords array
      fs.writeFileSync(absolutePath, JSON.stringify(this.keywords, null, 2));
      console.log(`[KeywordTrackingService] Write operation completed for ${absolutePath} (fallback mode)`);
    }
  }
  
  // Force save immediately (useful for server shutdown)
  public forceSave(): void {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
    
    if (this.pendingUpdates.size > 0) {
      this.saveKeywords();
      this.pendingUpdates.clear();
    }
  }
  
  // Test function to immediately track and save a keyword usage
  public testTrackAndSave(keywordId: number): boolean {
    const success = this.trackKeywordUsage(keywordId);
    if (success) {
      // Skip the timeout and save immediately
      if (this.saveTimeout) {
        clearTimeout(this.saveTimeout);
        this.saveTimeout = null;
      }
      this.saveKeywords();
      console.log(`[KeywordTrackingService] TEST: Immediately saved keyword ${keywordId} usage`);
    }
    return success;
  }
}
